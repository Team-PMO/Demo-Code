# Install Generative AI SDK.
!pip install -q -U google-generativeai

# Import libraries
from google.colab import files, userdata
import google.generativeai as genai
import re
from PIL import Image
import cv2
import numpy as np
from IPython.display import display

# Authenticate API
API_KEY = userdata.get('NikKey')
genai.configure(api_key=API_KEY)

# Load Gemini model
model = genai.GenerativeModel(model_name='gemini-1.5-pro')

# STEP 1: Upload and extract serial number from the tag
print("Upload the TAG photo (with serial number):")
tag_upload = files.upload()
tag_image_name = list(tag_upload.keys())[0]
print(f"Uploaded tag image: {tag_image_name}")
tag_img = Image.open(tag_image_name)

# Ask Gemini to extract the serial number from the tag image
serial_response = model.generate_content([
    tag_img,
    (
        "Extract the serial number from this product tag. "
        "Only return the serial number as plain text. "
        "If no serial number is visible, reply 'NO SERIAL NUMBER FOUND'."
    )
])
serial_number = serial_response.text.strip()
print(f"üîë Serial Number: {serial_number}")

if "NO SERIAL NUMBER FOUND" in serial_number.upper():
    print("‚ö†Ô∏è No serial number detected on the tag image.")
else:
    print(f"‚úÖ Serial number detected: {serial_number}")

# STEP 2: Upload the reference (perfect) image
print("\nUpload the REFERENCE (perfect) image:")
ref_upload = files.upload()
reference_image_name = list(ref_upload.keys())[0]
print(f"Uploaded reference image: {reference_image_name}")
reference_img = Image.open(reference_image_name)

# STEP 3: Upload the test (defective) image
print("\nUpload the TEST (inspection) image:")
test_upload = files.upload()
test_image_name = list(test_upload.keys())[0]
print(f"Uploaded test image: {test_image_name}")
test_img = Image.open(test_image_name)

# STEP 4: Compare images to detect defects
response = model.generate_content([
    reference_img,
    test_img,
    (
        "Compare these two product images. "
        "The first is the perfect reference, and the second is the test item. "
        "Identify only real imperfections or differences such as loose threads, tears, rips, stains, holes, fabric fraying, "
        "color inconsistencies, missing parts, or any other damage. "
        "If the two images are identical or no defects are found, explicitly respond with 'NO DEFECTS FOUND'. "
        "If defects are found, return them as a list: [ymin, xmin, ymax, xmax, defect_type]. "
        "Return separate lists for multiple defects."
    ),
])

# Show Gemini's response
result = response.text
print("\nGemini raw output:\n", result)

# Parse and draw results
def parse_bounding_box(response):
    bounding_boxes = re.findall(r'\[(\d+,\s*\d+,\s*\d+,\s*\d+,\s*[\w\s]+)\]', response)
    parsed_boxes = []
    for box in bounding_boxes:
        parts = box.split(',')
        numbers = list(map(int, parts[:-1]))
        label = parts[-1].strip()
        parsed_boxes.append((numbers, label))
    return parsed_boxes

if "NO DEFECTS FOUND" in result.upper():
    print("\n‚úÖ No defects detected. The test image matches the reference.")
else:
    bounding_box = parse_bounding_box(result)
    print(f"\nParsed bounding boxes: {bounding_box}")

    if bounding_box:
        label_colors = {}

        def draw_bounding_boxes(image, bounding_boxes_with_labels):
            if image.mode != 'RGB':
                image = image.convert('RGB')
            image = np.array(image)
            for bounding_box, label in bounding_boxes_with_labels:
                width, height = image.shape[1], image.shape[0]
                ymin, xmin, ymax, xmax = bounding_box
                x1 = int(xmin / 1000 * width)
                y1 = int(ymin / 1000 * height)
                x2 = int(xmax / 1000 * width)
                y2 = int(ymax / 1000 * height)

                if label not in label_colors:
                    color = np.random.randint(0, 256, (3,)).tolist()
                    label_colors[label] = color
                else:
                    color = label_colors[label]

                font = cv2.FONT_HERSHEY_SIMPLEX
                font_scale = 0.5
                font_thickness = 1
                box_thickness = 2
                text_size = cv2.getTextSize(label, font, font_scale, font_thickness)[0]

                text_bg_x1 = x1
                text_bg_y1 = y1 - text_size[1] - 5
                text_bg_x2 = x1 + text_size[0] + 8
                text_bg_y2 = y1

                cv2.rectangle(image, (text_bg_x1, text_bg_y1), (text_bg_x2, text_bg_y2), color, -1)
                cv2.putText(image, label, (x1 + 2, y1 - 5), font, font_scale, (255, 255, 255), font_thickness)
                cv2.rectangle(image, (x1, y1), (x2, y2), color, box_thickness)

            image = Image.fromarray(image)
            return image

        output = draw_bounding_boxes(test_img, bounding_box)
        display(output)
        output.save("output_image_with_defects.jpg")
        print("‚úÖ Defect image saved as 'output_image_with_defects.jpg'")
    else:
        print("‚ö†Ô∏è No bounding boxes detected, but Gemini did not confirm the images are identical.")
